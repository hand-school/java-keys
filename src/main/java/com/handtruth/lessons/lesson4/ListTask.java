package com.handtruth.lessons.lesson4;

import java.util.ArrayList;
import java.util.List;

class ListTask {

    /**
     * Easy
     * <p>
     * Найти количество неотрицательных элементов списка
     */
    public static int positiveCounter(List<Integer> list) {
        // TODO your code
        return 0;
    }

    /**
     * Easy
     * <p>
     * Найти максимальный элемент в списке
     * (Гарантируется, что список не пустой)
     */
    public static int maxNumber(List<Integer> list) {
        // TODO your code
        return 0;
    }

    /**
     * Medium (для нахождения решения за линейное время)
     * <p>
     * Найти все одинаковые элементы в списках
     * (все элементы отсортированы по возрастанию)
     */
    public static List<Integer> items(List<Integer> list1, List<Integer> list2) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     * <p>
     * Отсортировать входной спписок по возрастанию методом пузырьков
     * (алгоритм реализовать самостоятельно)
     */
    public static List<Integer> simpleSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     * <p>
     * Отсортировать входной список по возрастанию с помощью Merge Sort
     * (алгоритм реализовать самостоятельно)
     */
    public static List<Integer> mergeSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     * <p>
     * Отсортировать входной список по возрастанию с помощью Quick Sort
     * (алгоритм реализовать самостоятельно!)
     */
    public static List<Integer> quickSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     * <p>
     * Даны числа от 1 до 100
     * Отсортировать входной список по возрастанию
     * (линейное время)
     */
    public static List<Integer> linearSort(List<Integer> list) {
        // TODO your code
        return new ArrayList<>();
    }

    /**
     * Hard
     * <p>
     * Дан список содержащий значения типа Boolean (не null).
     * Необходимо найти наиболее длинную последовательность значений true.
     * Если посреди последовательности true встреается значение false (только одно и только один раз),
     * его можно проигнорировать и считать последовательность непрерывной (в длину такой последовательности не входит false).
     * Известно, что есть решение за линейное время :)
     * <p>
     * Пример :
     * на входе - {T,T,T,F,T,T,F,F,T,T,T,T}
     * ответ - 5
     */
    public static Integer longestTrueSequence(List<Boolean> list) {
        // TODO your code
        return 0;
    }
}
